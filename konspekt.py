'''Списки. 
Для створення порожнього списку існує два способи:'''

# my_list = list()

# empty_list = []

'''Щоб створити заповнений список:'''

# not_empty = [1, 2, 'user']
'''Приклад'''
cars = ['VW', 'Tesla', 'BMV', 'Toyota']
numbers = [1, 2, 56, 6]
a = ['Hello', 55, True, True, False, 55, None, 6.11, 'n', 4.5j]
print(cars)
print(numbers)
print(a)



'''Впорядковані контейнери. Доступ за індексом.
У Python синтаксис доступу за індексом виглядає так:
У першому рядку ми створили список з трьох перших літер англійського алфавіту.
У другому рядку ми зберегли у змінну first_letter літеру "a" — перший елемент some_iterable. 
Індекс у Python починається з 0, як і в більшості мов програмування, та індексом "a" є 0.
Третій рядок — це звернення до другого елементу some_iterable, його індекс дорівнює 1 — це літера "b" 
і ми зберігаємо її у middle_one. Четвертий рядок — це звернення до останнього елементу some_iterable, 
літери "c", ми збережемо її у last_letter і її індекс дорівнює 2.'''

# some_iterable = ["a", "b", "c"]
# first_letter = some_iterable[0]
# middle_one = some_iterable[1]
# last_letter = some_iterable[2]

'''Python підтримує індексування елементів з кінця. Для цього потрібно додати - і вказати номер елементу 
з кінця. Оскільки у Python -0 == 0, то перший елемент з кінця — це -1, другий — -2 і так далі.
Наш приклад можна переписати, використовуючи індексування з кінця, ось так:'''

# some_iterable = ["a", "b", "c"]
# first_letter = some_iterable[-3]
# middle_one = some_iterable[-2]
# last_letter = some_iterable[-1]

'''Найкориснішою властивістю списків є змінність списків, ви можете змінити значення будь-якого 
елементу списку:
В цьому прикладі ми змінили другий елемент списку some_iterable (другий елемент — це елемент з індексом 1) 
на 'Z'.'''

# some_iterable = ["a", "b", "c"]
# some_iterable[1] = "Z"
# print(some_iterable)    # ["a", "Z", "c"]

'''Зрізи у Python (Slice)
Для впорядкованих контейнерів є спеціальний синтаксис, коли нам необхідно отримати деяку послідовність 
елементів з контейнера. Наприклад, якщо ми хочемо отримати перші 5 літер рядку:
Синтаксис полягає у зазначенні індексу першого елементу зрізу, індексу, до якого (не включно) брати елементи 
в нову послідовність, та кроку, з яким брати елементи між початковим та кінцевим індексом у квадратних дужках, 
розділивши їх двокрапкою.'''

# some_str = "This is awesome string"
# first_five = some_str[0:5]       #first_five в цьому прикладі буде містити рядок 'This '.

'''Візьмімо список чисел від 1 до 10 і збережемо окремо парні, не парні та кратні 3.
У odd_numbers ми беремо числа, починаючи з індексу 0 до 10 з кроком 2 (отримаємо [1, 3, 5, 7, 9]). 
У even_numbers ми беремо числа, починаючи з індексу 1 до 10 з кроком 2 (отримаємо [2, 4, 6, 8]) 
У three_numbers ми беремо числа, починаючи з індексу 2 до 10 з кроком 3 (отримаємо [3, 6, 9]).'''

# numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

# odd_numbers = numbers[0:9:2]
# even_numbers = numbers[1:9:2]
# three_numbers = numbers[2:9:3]

'''Ви можете не вказувати початковий, кінцевий індекс або крок, пропускаючи його. За замовчуванням Python 
візьме зріз з початку до останнього елемента з кроком 1. Перепишемо попередній приклад у скороченому синтаксисі:
numbers_copy в цьому прикладі — це зріз, який бере всі елементи numbers від початку і до кінця з кроком 1.'''

# numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

# odd_numbers = numbers[::2]
# even_numbers = numbers[1::2]
# three_numbers = numbers[2:9:3]

# numbers_copy = numbers[:]

'''Також важливо пам'ятати, що в зріз не входить елемент з індексом, до якого брати елементи.
В цьому прикладі елемент з індексом 3 не увійде у first_three.'''

# numbers = [0, 1, 2, 3]
# first_three = numbers[0:3]  # [0, 1, 2]

'''Використання методів об'єктів
Доступ до методів об'єктів у Python синтаксично відбувається за допомогою символу крапки після імені об'єкту 
і зазначення імені методу або атрибуту, до якого потрібно отримати доступ.
В цьому прикладі ми використали метод append, який є у списків і він є у списку numbers. Цей метод додає новий
 елемент в кінець списку. Як аргумент цей метод отримує елемент, який потрібно додати до списку. 
 Аргументи вказуються в дужках.'''

# numbers = ['a', 'b']
# numbers.append('c')
# print(numbers)  # ['a', 'b', 'c']

'''Якщо метод не вимагає аргументів (наприклад метод clear), то дужки будуть порожніми:'''

# num = [1, 2]
# num.clear()
# print(num)  # []

'''МЕТОДИ СПИСКІВ'''
'''Додавання елементу в кінець списку: my_list.append(element)'''

# chars = ['a', 'b']
# chars.append('c')
# print(chars)  # ['a', 'b', 'c']

'''Видалення елементу зі списку викличе помилку, якщо такого елементу немає в списку: my_list.remove(element)'''

# chars = ['a', 'b']
# chars.remove('b')
# print(chars)  # ['a']

'''Повернути i-ий елемент та видалити його зі списку i_element = my_list.pop(i). 
За замовчуванням i = -1'''

# chars = ['a', 'b']
# last = chars.pop(1)
# print(chars)  # ['a']
# print(last)  # 'b'

'''Розширити список a_list елементами з b_list: a_list.extend(b_list)'''

# chars = ['a', 'b']
# numbers = [1, 2]

# chars.extend(numbers)
# print(chars)  # ['a', 'b', 1, 2]

'''Вставити x на позицію з індексом i: my_list.insert(i, x)'''

# chars = ["a", "b"]
# chars.insert(1, "c")
# print(chars)  # ['a', 'c', 'b']

'''Очистити список: my_list.clear()'''

# chars = ['a', 'b']
# last =  chars.clear() 
# print(chars) # []

'''Знайти індекс першого елемента у списку, що дорівнює x: index = my_list.index(x)'''

# chars = ['a', 'b', 'c', 'd']
# c_ind = chars.index('c') 
# print(c_ind) #2

'''Повернути кількість елементів у списку, що дорівнюють x: x_number = my_list.count(x)'''

# chars = ['a', 'b', 'c', 'a']
# a_count = chars.count('a')
# print(a_count) # 2

'''Відсортувати список за зростанням: my_list.sort(key=None, reverse=False)'''

# chars = ['z', 'a', 'b']
# chars.sort()
# print(chars) # ['a', 'b', 'z']

'''Змінити порядок елементів у списку на зворотний: my_list.reverse()'''

# chars = ['a', 'b']
# chars.reverse()
# print(chars) # ['b', 'a']

'''Повернути копію списку: copy_of_my_list = my_list.copy()'''

# chars =  ['a', 'b']
# chars_copy = chars.copy()
# chars == chars_copy # True

'''МЕТОДИ СЛОВНИКІВ'''
'''Деякі методи словників, що найчастіше використовуються:'''

'''pop(key) — повертає значення елементу і видаляє пару ключ-значення зі словника'''

# chars = {'a': 1, 'b': 2}
# b_num = chars.pop('b')
# print(chars)  # {'a': 1}
# print(b_num)  # 2

'''update(another_dict) — розширює словник значеннями з іншого словника'''

# chars = {'a': 1, 'b': 2}
# chars.update({"c": 3})
# print(chars)  # {'a': 1, 'b': 2, "c": 3}

'''clear() — очищає словник, не створюючи нового'''

# chars = {'a': 1, 'b': 2}
# chars.clear()
# print(chars)  # {}

'''copy() — повертає копію словника'''

# chars = {'a': 1, 'b': 2}
# chars_copy = chars.copy()
# chars_copy == chars  # True

'''get(key[, default]) — не викликає виключення, якщо ключа немає в словнику, повертає default, 
за замовчуванням default=None.'''

# chars = {'a': 1, 'b': 2}
# c_idx = chars.get('c', -1)
# print(c_idx)  # -1

'''ЦИКЛ ТА СЛОВНИКИ'''
'''Ітерування за словником — це блок коду, що дуже часто зустрічається, і корисно вміти це робити.
Спершу варто сказати, що словник сам по собі — це ітерований контейнер і за ним можна ітеруватися 
в циклі for без необхідності заводити якийсь зовнішній лічильник тощо. Створимо словник, в якому ключами 
будуть числа, а значеннями — числівники англійською:'''

# numbers = {
#     1: "one",
#     2: "two",
#     3: "three"
# }

'''Тепер давайте просто пройдемо словником в циклі та виведемо, що нам повертає ітератор на кожній ітерації:'''

# for key in numbers:
#     print(key)

'''У виведенні ви побачите:'''

# 1
# 2
# 3

'''Ітеруючи за словником, ви перебираєте ключі словника. Таку саму поведінку можна отримати, 
використовуючи метод keys, але так ви явно вкажете, що хочете перебрати ключі:'''

# for key in numbers.keys():
#     print(key)

'''Відповідь буде точно такою самою:'''

# 1
# 2
# 3

'''Часто необхідно перебрати саме значення словника, для цього скористаємося методом values:'''

# for val in numbers.values():
#     print(val)

'''У виведенні буде:'''

# one
# two
# tree

'''І переберемо пари ключ значення, використовуючи метод items. На кожній ітерації ми отримаємо пару 
(ключ, значення):'''

# for key, value in numbers.items():
#     print(key, value)

'''Виведення:'''

# 1 one
# 2 two
# 3 three

'''Що не можна робити, поки ітеруєтеся за словником: не можна видаляти елементи із словника, 
не можна додавати елементи у словник. Але можна перезаписувати значення, якщо ви ітеруєтеся за ключами.'''

'''МНОЖИНИ'''
'''Множини — це неврегульований контейнер, який містить тільки унікальні елементи. У множину можна додавати 
тільки незмінні типи даних.
Є тільки один спосіб створити порожню множину:'''

# a = set()
# print(a)    # set()

'''Для створення заповненої множини достатньо передати будь-який об'єкт, що ітерується, в функцію set:'''

# a = set('hello')
# print(a)    # {'e', 'h', 'l', 'o'}

'''Або ж скористатися синтаксисом з фігурними дужками (як у словниках), але елементи у фігурних дужках 
просто перелічити через кому без двокрапок:'''

# b = {1, 2, 3, 4}

'''Унікальність має на увазі, що якщо множина вже містить такий елемент, то спроба додати ще один такий 
самий нічого не змінить.'''

# numbers = {1, 2, 3, 1, 2, 3}
# print(numbers)    # {1, 2, 3}






